
namespace TfmrLib.FEM
{
    public class GetDPAxiElecProblem : GetDPProblem
    {
        protected override void WriteGetDPFile()
        {
            base.WriteGetDPFile();
            Console.WriteLine($"Appending Electrostatics definitions to {Filename}");
            var f = File.AppendText(Filename);
            f.WriteLine();
            f.WriteLine("// Additional definitions for Electrostatics");
            f.WriteLine("// Auto-generated by TfmrLib");
            f.WriteLine();

            f.WriteLine("Vol_Ele = Region[{");
            foreach (var reg in Regions)
            {
                f.Write($"{reg.Name}");
                if (reg != Regions.Last())
                    f.Write(", ");
            }

            f.WriteLine(")}];");
            f.Write("Sur_C_Ele = Region[{");

            foreach (var exc in Excitations)
            {
                f.Write($"{exc.Region.Name}");
                if (exc != Excitations.Last())
                    f.Write(", ");
            }
            f.WriteLine("}];");

            // Need to define Sur_Neu_Ele if there are Neumann BCs
            f.Write("Sur_Neu_Ele = Region[{");
            foreach (var bc in BoundaryConditions.OfType<NeumannBoundaryCondition>())
            {
                f.Write($"{bc.Name}");
                if (bc != BoundaryConditions.OfType<NeumannBoundaryCondition>().Last())
                    f.Write(", ");
            }
            f.WriteLine("}];");
            
            // Need to assign dn on Sur_Neu_Ele if there are Neumann BCs
            foreach (var bc in BoundaryConditions.OfType<NeumannBoundaryCondition>())
            {
                f.WriteLine($@"Function {{ dn[Region[{{{bc.Name}}}]] = {bc.Flux}; }}");
            }


            // Define epsr in regions
            foreach (var region in Regions)
            {
                if (region.TryGetProperty("eps_r", out double epsr))
                {
                    f.WriteLine($@"Function {{ epsr[Region[{{{region.Name}}}]] = {epsr}; }}");
                }
                else
                {
                    throw new Exception($"Region '{region.Name}' must have an 'eps_r' property defined for electrostatics");
                }
            }

            // Define Sur_C_Ele for floating conductors
            f.WriteLine("Constraint {");
            f.WriteLine("  { Name ElectricScalarPotential; Type Assign;");
            f.WriteLine("    Case {");
            foreach (var bc in BoundaryConditions.OfType<DirichletBoundaryCondition>())
            {
                f.WriteLine($"      {{ Region Region[{{{bc.Name}}}]; Value {bc.Potential}; }}");
            }
            f.WriteLine("    }");
            f.WriteLine("  }");
            f.WriteLine("  { Name GlobalElectricPotential; Type Assign;");
            f.WriteLine("    Case {");
            foreach (var exc in Excitations)
            {
                f.WriteLine($"      {{ Region Region[{{{exc.Region.Name}}}]; Value {exc.Value}; }}");
            }
            f.WriteLine("    }");
            f.WriteLine("  }");
            f.WriteLine("  { Name GlobalElectricCharge; Case { } }");
            f.WriteLine("}");
            f.WriteLine();

            f.WriteLine("Group{");
            f.WriteLine("   Vol_Elec += Region[ProblemDomain];");
            f.WriteLine("}");

            f.WriteLine();
            f.WriteLine("Group {");
            f.WriteLine("  DefineGroup[");
            f.WriteLine("    // The full electric domain:");
            f.WriteLine("    Vol_Elec,");
            f.WriteLine("    // Boundaries:");
            f.WriteLine("    Sur_Neu_Elec, // surfaces with Neumann BCs");
            f.WriteLine("    Sur_C_Elec, // boundaries of conductors");
            f.WriteLine("  ];");
            f.WriteLine("  Dom_Elec = Region[ {Vol_Elec, Sur_Neu_Elec} ];");
            f.WriteLine("}");

            f.WriteLine("Function {");
            f.WriteLine("  DefineFunction[");
            f.WriteLine("    epsr, // relative permittivity (in Vol_Elec)");
            f.WriteLine("    rho, // free charge density (in Vol_Q_Elec)");
            f.WriteLine("    dn // normal displacement (on Sur_Neu_Elec)");
            f.WriteLine("  ];");
            f.WriteLine("}");
            f.WriteLine();
            
            f.WriteLine();
            f.WriteLine("Jacobian {");
            f.WriteLine("  { Name Vol;");
            f.WriteLine("    Case {");
            f.WriteLine("      { Region All; Jacobian VolAxiSqu; }");
            f.WriteLine("    }");
            f.WriteLine("  }");
            f.WriteLine("  { Name Sur;");
            f.WriteLine("    Case {");
            f.WriteLine("      { Region All; Jacobian SurAxi; }");
            f.WriteLine("    }");
            f.WriteLine("  }");
            f.WriteLine("}");
            f.WriteLine();
            f.WriteLine("Integration {");
            f.WriteLine("   { Name Gauss_v;");
            f.WriteLine("     Case {");
            f.WriteLine("       { Type Gauss;");
            f.WriteLine("         Case {");
            f.WriteLine("           { GeoElement Point; NumberOfPoints 1; }");
            f.WriteLine("           { GeoElement Line; NumberOfPoints 3; }");
            f.WriteLine("           { GeoElement Triangle; NumberOfPoints 3; }");
            f.WriteLine("           { GeoElement Quadrangle; NumberOfPoints 4; }");
            f.WriteLine("           { GeoElement Tetrahedron; NumberOfPoints 4; }");
            f.WriteLine("           { GeoElement Hexahedron; NumberOfPoints 6; }");
            f.WriteLine("           { GeoElement Prism; NumberOfPoints 9; }");
            f.WriteLine("           { GeoElement Pyramid; NumberOfPoints 8; }");
            f.WriteLine("         }");
            f.WriteLine("       }");
            f.WriteLine("     }");
            f.WriteLine("   }");
            f.WriteLine("}");
            f.WriteLine();
            // The following FunctionSpace means we need to define regions for Dom_Elec and Vol_Elec
            // as well as (if used) boundary conditions for ElectricScalarPotential_2D and ElectricScalarPotential_2D_0
            f.WriteLine("FunctionSpace {");
            f.WriteLine("  { Name Hgrad_vf_Elec; Type Form0;");
            f.WriteLine("    BasisFunction {");
            f.WriteLine("      // v = v  s  + v    s");
            f.WriteLine("      //      n  n    c,k  c,k");
            f.WriteLine("      { Name sn; NameOfCoef vn; Function BF_Node;");
            f.WriteLine("        Support Dom_Elec; Entity NodesOf[ All, Not Sur_C_Elec ]; }");
            f.WriteLine("      { Name sck; NameOfCoef vck; Function BF_GroupOfNodes;");
            f.WriteLine("        Support Vol_Elec; Entity GroupsOfNodesOf[ Sur_C_Elec ]; }");
            f.WriteLine("    }");
            f.WriteLine("    SubSpace { // only for a PostOperation");
            f.WriteLine("      { Name vf; NameOfBasisFunction sck; }");
            f.WriteLine("    }");
            f.WriteLine("    GlobalQuantity {");
            f.WriteLine("      { Name GlobalElectricPotential; Type AliasOf; NameOfCoef vck; }");
            f.WriteLine("      { Name GlobalElectricCharge; Type AssociatedWith; NameOfCoef vck; }");
            f.WriteLine("    }");
            f.WriteLine("    Constraint {");
            f.WriteLine("      { NameOfCoef vn;");
            f.WriteLine("        EntityType NodesOf; NameOfConstraint ElectricScalarPotential; }");
            f.WriteLine("      { NameOfCoef GlobalElectricPotential;");
            f.WriteLine("        EntityType GroupsOfNodesOf; NameOfConstraint GlobalElectricPotential; }");
            f.WriteLine("      { NameOfCoef GlobalElectricCharge;");
            f.WriteLine("        EntityType GroupsOfNodesOf; NameOfConstraint GlobalElectricCharge; }");
            f.WriteLine("    }");
            f.WriteLine("  }");
            f.WriteLine("}");
            f.WriteLine();
            
            f.WriteLine("Formulation {");
            f.WriteLine("  { Name Electrostatics_vf; Type FemEquation;");
            f.WriteLine("    Quantity {");
            f.WriteLine("      { Name v; Type Local; NameOfSpace Hgrad_vf_Elec; }");
            f.WriteLine("      { Name Q; Type Global;");
            f.WriteLine("        NameOfSpace Hgrad_vf_Elec [GlobalElectricCharge]; }");
            f.WriteLine("      { Name V; Type Global;");
            f.WriteLine("        NameOfSpace Hgrad_vf_Elec [GlobalElectricPotential]; }");
            f.WriteLine("      // only for a PostOperation");
            f.WriteLine("      { Name vf; Type Local; NameOfSpace Hgrad_vf_Elec [vf]; }");
            f.WriteLine("    }");
            f.WriteLine("    Equation {");
            f.WriteLine("      Integral { [ epsr[] * eps0 * Dof{d v} , {d v} ];");
            f.WriteLine("        In Vol_Elec; Jacobian Vol; Integration Int; }");
            f.WriteLine("      Integral { [ - rho[], {v} ];");
            f.WriteLine("        In Vol_Q_Elec; Jacobian Vol; Integration Int; }");
            f.WriteLine("      Integral { [ dn[] , {v} ];");
            f.WriteLine("        In Sur_Neu_Elec; Jacobian Sur; Integration Int; }");
            f.WriteLine("      GlobalTerm { [ - Dof{Q}, {V} ]; In Sur_C_Elec; }");
            f.WriteLine("    }");
            f.WriteLine("  }");
            f.WriteLine("}");
            f.WriteLine();

            f.WriteLine("Resolution {");
            f.WriteLine("  { Name Electrostatics_v;");
            f.WriteLine("    System {");
            f.WriteLine("      { Name A; NameOfFormulation Electrostatics_vf; }");
            f.WriteLine("    }");
            f.WriteLine("    Operation {");
            f.WriteLine("      Generate[A]; Solve[A]; SaveSolution[A];");
            f.WriteLine("    }");
            f.WriteLine("  }");
            f.WriteLine("}");
            f.WriteLine();

            f.WriteLine("PostProcessing {");
            f.WriteLine("  { Name Electrostatics_v; NameOfFormulation Electrostatics_vf;");
            f.WriteLine("    PostQuantity {");
            f.WriteLine("      { Name v; Value {");
            f.WriteLine("          Term { [ {v} ]; In Vol_Elec; Jacobian Vol; }");
            f.WriteLine("        }");
            f.WriteLine("      }");
            f.WriteLine("      { Name e; Value {");
            f.WriteLine("          Term { [ -{d v} ]; In Vol_Elec; Jacobian Vol; }");
            f.WriteLine("        }");
            f.WriteLine("      }");
            f.WriteLine("      { Name d; Value {");
            f.WriteLine("          Term { [ -eps0*epsr[] * {d v} ]; In Vol_Elec; Jacobian Vol; }");
            f.WriteLine("        }");
            f.WriteLine("      }");
            f.WriteLine("      { Name Q; Value {");
            f.WriteLine("          Term { [ {Q} ]; In Sur_C_Elec; }");
            f.WriteLine("        }");
            f.WriteLine("      }");
            f.WriteLine("      { Name V; Value {");
            f.WriteLine("          Term { [ {V} ]; In Sur_C_Elec; }");
            f.WriteLine("        }");
            f.WriteLine("      }");
            f.WriteLine("      { Name C; Value {");
            f.WriteLine("          Term { [ {Q}/{V} ]; In Sur_C_Elec; }");
            f.WriteLine("        }");
            f.WriteLine("      }");
            f.WriteLine("      { Name vf; Value {");
            f.WriteLine("          Term { [ {vf} ]; In Vol_Elec; Jacobian Vol; }");
            f.WriteLine("        }");
            f.WriteLine("      }");
            f.WriteLine("      { Name force; Value {");
            f.WriteLine("          Integral { [ eps0*epsr[] / 2. * VirtualWork[{d v}] ];");
            f.WriteLine("            //In Vol_Elec; // restrict support to speed-up search");
            f.WriteLine("            In ElementsOf[Vol_Elec, OnOneSideOf Sur_C_Elec];");
            f.WriteLine("            Jacobian Vol; Integration Int;");
            f.WriteLine("          }");
            f.WriteLine("        }");
            f.WriteLine("      }");
            f.WriteLine("      { Name energy; Value {");
            f.WriteLine("          Integral {  [ eps0*epsr[] / 2. * SquNorm[{d v}] ];");
            f.WriteLine("            In Vol_Elec; Jacobian Vol; Integration Int;");
            f.WriteLine("          }");
            f.WriteLine("        }");
            f.WriteLine("      }");
            f.WriteLine("    }");
            f.WriteLine("  }");
            f.WriteLine("}");
            f.WriteLine();

            f.WriteLine("PostOperation {");
            f.WriteLine("  { Name Electrostatics_v; NameOfPostProcessing Electrostatics_v;");
            f.WriteLine("    Operation {");
            f.WriteLine("      //Print[ e, OnElementsOf Vol_Elec, File \"e.pos\"];");
            f.WriteLine("      //Print[ v, OnElementsOf Vol_Elec, File \"v.pos\"];");
            f.WriteLine("      //Echo[ \"Microstrip capacitance [F]:\", Format Table, \"out.txt\"];");
            f.WriteLine("      Print[ C, OnRegion Sur_C_Elec, File \"out.txt\",");
            f.WriteLine("	    Format Table, SendToServer \"Output/Global/Capacitance [F]\" ];");
            f.WriteLine("      Print[ energy [Vol_Elec], OnGlobal, File \"out3.txt\",");
            f.WriteLine("	    Format Table, SendToServer \"Output/Global/Energy\" ];");
            f.WriteLine("        If(NbrRegions[Sur_C_Elec])");
            f.WriteLine("        Print[ Q, OnRegion Sur_C_Elec, File \"q.txt\",");
            f.WriteLine("          Format Table, SendToServer \"Output/Floating charge [C]\" ];");
            f.WriteLine("        Print[ V, OnRegion Sur_C_Elec, File \"v.txt\",");
            f.WriteLine("          Format Table, SendToServer \"Output/Floating potential [V]\" ];");
            f.WriteLine("      EndIf");
            f.WriteLine("    }");
            f.WriteLine("  }");
            f.WriteLine("}");
            f.Close();
        }

    }
}